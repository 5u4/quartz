{"/":{"title":"Sen Hung WONG","content":"Sen Hung is currently doing MScIT degree in HKUST, and working in Hong Kong Asian Ark Technologies as a software developer. He is passionate about software design, web development, and problem solving. He is interested in TypeScript, Rust, Python, and enjoys solving challenging problems and learning new technologies.\n\n[Notes](/notes)","lastmodified":"2022-04-11T14:13:39.14642169Z","tags":null},"/notes/20220314-summary-of-my-crypto-investment-in-these-days":{"title":"Summary of my crypto investment in these days","content":"1. I started to do simple trading investment on BTC perpetual market at \u003ca href=\"https://ftx.com\" target=\"_blank\" rel=\"noopener\"\u003eftx.com\u003c/a\u003e (zero fees on limit orders).\n   Til writing this post, I have earned 400+ USD with 2000 USD capital and each order has a 6000 USD notional.\n\n2. I was lucky sometimes that I bought on the local minimum and sold on peak; but that's not always the case.\n   I have once bought on the high point and the price goes straight down.\n   I believe the price will eventually goes up to my desired point. That price took around a day to go back.\n   So when the price drop, believe in BTC and just wait...\n\n3. I could split my orders into multiple chunks.\n   Some weighted heavier and take lower risk (earn less); the others are placed on ambitious closing point.\n\n## A few questions\n\n- Can I automate these?\n- When my capital grow, can the market take my order? (or will my order affect the market?)","lastmodified":"2022-04-11T14:13:39.14642169Z","tags":null},"/notes/20220316-zero-knowledge-proof-and-gossip":{"title":"Zero knowledge proof \u0026 gossip","content":"Zero knowledge (zk) is a way to prove someone knows a certain secret but without revealing any information to the validator and the outside world.\n\nZero knowledge proof has three characteristics:\n\n- **Completeness**: if the prover knows some secret, verifier can verify they indeed know the secret by doing some steps.\n- **Soundness**: if the prover does not know the secret, no matter how they fake the steps, the verifier would reject.\n- **Zero-knowledge**: While proving, the prover will leak no information about the secret.\n\n## Some random thinking about zk and gossip\n\nWhile I was browsing Weibo, I found people like to share some hearsay to satisfy their vanity\nbut are afraid of leaking the critical information.\n\nJust some random thinking; a zk proof is excellent for this use case if it can be somehow proved. ðŸ¤”","lastmodified":"2022-04-11T14:13:39.14642169Z","tags":null},"/notes/20220324-a-smart-way-to-solve-leetcode-boats-to-save-people-in-rust":{"title":"A smart way to solve Leetcode boats to save people in Rust","content":"While I was solving [881. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/), I found out a special issue on Rust.\n\nThe following solution should work normally in other languages like Java.\n\n```rs\nimpl Solution {\n    pub fn num_rescue_boats(people: Vec\u003ci32\u003e, limit: i32) -\u003e i32 {\n        let mut people = people;\n        people.sort_unstable();\n\n        let mut count = 0;\n        let mut i = 0;\n        let mut j = people.len() - 1;\n\n        while i \u003c= j {\n            if people[i] + people[j] \u003c= limit {\n                i += 1;\n            }\n            j -= 1;\n            count += 1;\n        }\n\n        count\n    }\n}\n```\n\nHowever, the program panics on the following test case:\n\n```rs\n#[test]\nfn example3() {\n    let actual = Solution::num_rescue_boats(vec![3, 5, 3, 4], 5);\n    let expected = 4;\n    assert_eq!(actual, expected);\n}\n\n// thread '...' panicked at 'attempt to subtract with overflow' ...\n```\n\nThe reason is that `j` is an `usize` which cannot be subtracted below 0.\n\nI found out a smart solution that deals with the edge case elegantly. It counts all people first\nand then subtract count when there are more than 1 people can take the boat.\n\n```rs\nimpl Solution {\n    pub fn num_rescue_boats(people: Vec\u003ci32\u003e, limit: i32) -\u003e i32 {\n        let mut people = people;\n        people.sort_unstable();\n\n        let mut count = people.len() as i32;\n        let mut i = 0;\n        let mut j = people.len() - 1;\n\n        while i \u003c j {\n            if people[i] + people[j] \u003c= limit {\n                i += 1;\n                count -= 1;\n            }\n            j -= 1;\n        }\n\n        count\n    }\n}\n```","lastmodified":"2022-04-11T14:13:39.14642169Z","tags":null},"/notes/20220325-copilot-is-so-great":{"title":"Copilot is so great!","content":"I got in copilot preview today and I tried it with a Leetcode question. Dispite it cannot solve the problem,\nit provides great hint on the solution. This would be a great help if can be used during development!","lastmodified":"2022-04-11T14:13:39.14642169Z","tags":null}}